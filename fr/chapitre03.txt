$comment(-*- coding: utf-8 -*- vim:set encoding=utf-8:)$
Traduction à partir de l'anglais par Jean-Denis VAUGUET

h1. Chapitre 3 : Noms et table de nommage

h2. `st_table`

Vous connaissez déjà `st_table` comme table stockant méthodes et instances.
Dans ce chapitre, nous allons voir plus en détail son fonctionnement.

h3. En bref

J'ai mentionné précédemment que `st_table` est une table de hachage. Qu'est-ce
qu'une table de hachage ? Une structure de données qui enregistre des relations
unaires (1-à-1), par exemple un nom de variable et sa valeur, le nom d'une
fonction et son corps, etc.

Toutefois, les tables de hachages ne sont pas les seules à pouvoir stocker des
relations unaires. Prenez par exemple une liste de structures de données comme
celle présentées ci-dessous : elle suffira pleinement dans cette optique.

<pre class="emlist">
struct entry {
    ID key;
    VALUE val;
    struct entry *next;  /* pointe vers l'entrée suivante */
};
</pre>

Cette méthode est cependant lente. Si la liste contient une centaine d'item,
dans le pire des cas, il faut travers cent liens. En définitive, la durée de
rechercher croit proportionnellement avec le nombre d'éléments, ce qui est
pénalisant. Depuis maintenant fort longtemps, diverses méthodes accélérant les
structures de données ont été imaginées. La table de hachage est l'une de ces
méthodes. Finalement, le point clé n'est pas qu'une table de hachage est néces-
saire, mais qu'elle est plus rapide.

Maintenant, examinons de plus près `st_table`. Avant toute chose, sachez que
cette librairie n'a pas été créée par Matsumoto :

▼ `st.c` credits
<pre class="longlist">
   1  /* This is a public domain general purpose hash table package
         written by Peter Moore @ UCB. */

(st.c)
</pre>

Évidemment, j'ai fait une recherche sur Google à propos d'une autre version,
et il en est ressorti que st_table est la contraction de « STring TABLE. »
J'ai trouvé cela plutôt contradictoire : une table ayant à la fois un but
général (_"general purpose"_) et des aspects liés aux chaînes de caractères
(_"string"_).

h4. Qu'est-ce qu'une table de hachage ?

Une table de hachage peut se conceptualiser ainsi : d'abord, imaginons un
tableau de n items. Prenons par exemple n = 64 (figure 1).

!images/ch_name_array.png(Tableau)!

Puis, définissons une fonction f qui, avec une clé, produit un entier i entre
0 et n-1 (ici, 0-63). f sera appelée « fonction de hachage » : elle donne le
même entier i si on lui toujours passe la même clé. Par exemple, si on fait
la supposition que la clé est choisie dans les entiers positifs uniquement,
alors la clé sera divisée par 64, si bien que la partie entière sera toujours
comprise entre 0 et 63. Cette méthode de calcul pourrait definir l'expression
fonctionnelle de f.

Lorsqu'on enregistre des relations, étant donné une clé, la fonction f génère
un entier i, et place la valeur à l'index i du tableau que nous avons préparé.
En d'autres termes, l'accès à l'index d'un tableau est très rapide. L'idée
fondamentale ici est de transformer la clé en entier.

!images/ch_name_aset.png(Enregistrement dans le tableau)!

En réalité, tout n'est pas aussi simple dans le monde réel. Il y a un problème
critique avec cette idée de clé. Du fait que n vaut 64, si le nombre de relations
dépasse 64, alors il est certain que deux clés seront associées au même entier i.
Cela peut même se produire avec moins de 64 clés. Par exemple, avec la fonction
de hachage précédente « clé % 64 », les clés 65 et 129 auront la même valeur de
hachage de 1. Voilà une collision de valeurs de hachage ; il y a plusieurs façons
de les gérer.

Première façon : si une collision survient, alors on peut enregistrer la valeur
dans l'élément suivante. C'est l'adressage ouvert (figure 3).

!images/ch_name_nexti.png(Open addressing)!

Plutôt que d'utiliser le tableau ainsi, d'autres approches sont possibles,
comme par exemple utiliser un pointeur vers une liste chaînée dans chaque
cellule du tableau. Lorsqu'il y a collision, il suffit de faire grandir la
liste idoine. Cela s'appelle du chaînage (figure 4) et c'est la méthode
utilisée par `st_table`.

!images/ch_name_chain.png(Chaining)! 

Cependant, si on arrive à déterminer _a priori_ quel est l'ensemble de clés
qui sera utilisé, on peut éviter toute collision en choisissant avec soins
la fonction de hachage. Ce type de fonction est appellée « fonction de
hachage parfaite. » Il y a en fait plusieurs outils qui créent de telles
fonctions étant donné une sélection arbitraire de chaînes. GNU gperf est l'un
d'eux, et le parseur de `ruby` utilise GNU gperf, mais... ce n'est pas encore
le temps de parler de ça. Cela viendra dans la seconde partie du livre.

h3. Structure de données

Attaquons maintenant le code source. Comme je l'ai écrit dans le chapitre
introductif, s'il y a à la fois des données et du code, il vaut mieux lire
les données en premier. Ce qui suit est le type de donnée de `st_table`.

▼ `st_table`
<pre class="longlist">
   9  typedef struct st_table st_table;

  16  struct st_table {
  17      struct st_hash_type *type;
  18      int num_bins;                   /* slot count */
  19      int num_entries;                /* nombre total d'entrées */
  20      struct st_table_entry **bins;   /* slot */
  21  };

(st.h)
</pre>

▼ `struct st_table_entry`
<pre class="longlist">
  16  struct st_table_entry {
  17      unsigned int hash;
  18      char *key;
  19      char *record;
  20      st_table_entry *next;
  21  };

(st.c)
</pre>

`st_table` est la structure principale de la table. `st_table_entry` est un
réceptacle qui contient une valeur. `st_table_entry` contient un membre `next`
qui, triviallement, permet de lier des entrées et fait de `st_table_entry`
une liste chaînée. C'est la partie « chaîne » de la méthode de chaînage. Le
type de donnée `st_hash_table` utilisé sera expliqué par la suite. D'abord,
laissez-moi vous expliquer les autres éléments de sorte que vous puissiez
comprendre et comparer leurs rôles.

!images/ch_name_sttable.png(structure de données `st_table`)!

Faisons donc quelques commentaires à propos de `st_hash_type`.

▼ `struct st_hash_type`
<pre class="longlist">
  11  struct st_hash_type {
  12      int (*compare)();   /* fonction de comparaison */
  13      int (*hash)();      /* fonction de hachage */
  14  };

(st.h)
</pre>

Nous n'en sommes qu'au chapitre 3, aussi examinons tout ça attentivement.

<pre class="emlist">
int (*compare)()
</pre>

Cette partie montre évidement le membre `compare`, qui a pour type de données
« un pointeur vers une fonction retournant un `int`. » `hash` est du même type.
Cette variable est substituée de la manière suivante :

<pre class="emlist">
int
super_fonction(int n)
{
    /* ToDo: faire réellement quelque chose ! */
    return n;
}

{
    int (*f)();
    f = super_fonction;
</pre>

Et elle est appellée comme suit :

<pre class="emlist">
    (*f)(7);
}
</pre>

Revenons ici sur le commentaire à propos de `st_hash_type`. De des membres
`hash` et `compare`, `hash` est la fonction de hachage f dors-et-déjà
présentée.

L'autre membre, `compare`, est une fonction qui détermine si la clé est la
même ou non. Avec la méthode de chaînage, plusieurs éléments peuvent être
insérés dans un seul et même emplacement, grâce à la fonction de hachage.
Afin de savoir quel élément exactement est recherché, il faut cette fois
utiliser une fonction de comparaison dans laquelle nous pouvons avoir une
confiance absolue. `compare` sera cette fonction.

Cette structure `st_hash_type` est une bonne technique généralisée. La table
de hachage en elle-même ne sait pas déterminer quel type de donnée les clés
stockées auront. Par exemple, dans `ruby`, les clés de `st_table` peuvent
être des `ID`, ou `char*`, ou encore `VALUE`, mais écrire le même genre de
hachage pour chacun de ces cas de figure est maladroit. Généralement, ce qui
change en même temps que le type de données des clés sera en fait la fonction
de hachage. Pour tout ce qui touche à l'allocation mémoire et la détection des
collisions, la plus grande partie du code reste inchangée. Ainsi, seule les
parties du code affectée par un changement du type de données des clés sera
mis sous la forme de fonction, et un pointeur vers cette fonction sera utilisé.
Grâce à cela, la majeure partie du code qui constitue l'implémentation du
processus de hachage pourra l'utiliser.

Dans les langages orientés objet, une première chose possible consiste à passer
à _quelque chose_ un objet auquel vous aurez attaché une procédure, si bien
que ce genre d'astuce n'est pas nécessaire. Ou alors, peut-être est-il plus
juste de dire que ces astuces sont directement implémentées comme fonctionnalités
du langage.

h3. `st_hash_type` example

The usage of a data structure like `st_hash_type` is good as an
abstraction. On the other hand, what kind of code it actually passes
through may be difficult to understand. If we do not examine what sort of
function is used for `hash` or `compare`, we will not grasp the reality.
To understand this, it is probably sufficient to look at `st_init_numtable()`
introduced in the previous chapter. This function creates a table for
integer data type keys.

▼ `st_init_numtable()`
<pre class="longlist">
 182  st_table*
 183  st_init_numtable()
 184  {
 185      return st_init_table(&type_numhash);
 186  }

(st.c)
</pre>

`st_init_table()` is the function that allocates the table memory and so
on. `type_numhash` is an `st_hash_type` (it is the member named "type" of `st_table`).
Regarding this `type_numhash`:

▼ `type_numhash`
<pre class="longlist">
  37  static struct st_hash_type type_numhash = {
  38      numcmp,
  39      numhash,
  40  };

 552  static int
 553  numcmp(x, y)
 554      long x, y;
 555  {
 556      return x != y;
 557  }

 559  static int
 560  numhash(n)
 561      long n;
 562  {
 563      return n;
 564  }

(st.c)
</pre>

Very simple. The table that the `ruby` interpreter uses is by and large
this `type_numhash`.

h3. `st_lookup()`

Now then, let us look at the function that uses this data structure. First,
it's a good idea to look at the function that does the searching. Shown below is the
function that searches the hash table, `st_lookup()`.

▼ `st_lookup()`
<pre class="longlist">
 247  int
 248  st_lookup(table, key, value)
 249      st_table *table;
 250      register char *key;
 251      char **value;
 252  {
 253      unsigned int hash_val, bin_pos;
 254      register st_table_entry *ptr;
 255
 256      hash_val = do_hash(key, table);
 257      FIND_ENTRY(table, ptr, hash_val, bin_pos);
 258
 259      if (ptr == 0) {
 260          return 0;
 261      }
 262      else {
 263          if (value != 0)  *value = ptr->record;
 264          return 1;
 265      }
 266  }

(st.c)
</pre>

The important parts are pretty much in `do_hash()` and `FIND_ENTRY()`. Let us
look at them in order.

▼ `do_hash()`
<pre class="longlist">
  68  #define do_hash(key,table) (unsigned int)(*(table)->type->hash)((key))

(st.c)
</pre>

Just in case, let us write down the macro body that is difficult to understand:

<pre class="emlist">
(table)->type->hash
</pre>

is a function pointer where the `key` is passed as a parameter. This is the
syntax for calling the function. `*` is not applied to `table`. In other words,
this macro is a hash value generator for a `key`, using the prepared hash
function `type->hash` for each data type.

Next, let us examine `FIND_ENTRY()`.

▼ `FIND_ENTRY()`
<pre class="longlist">
 235  #define FIND_ENTRY(table, ptr, hash_val, bin_pos) do {\
 236      bin_pos = hash_val%(table)->num_bins;\
 237      ptr = (table)->bins[bin_pos];\
 238      if (PTR_NOT_EQUAL(table, ptr, hash_val, key)) {\
 239          COLLISION;\
 240          while (PTR_NOT_EQUAL(table, ptr->next, hash_val, key)) {\
 241              ptr = ptr->next;\
 242          }\
 243          ptr = ptr->next;\
 244      }\
 245  } while (0)

 227  #define PTR_NOT_EQUAL(table, ptr, hash_val, key) ((ptr) != 0 && \
          (ptr->hash != (hash_val) || !EQUAL((table), (key), (ptr)->key)))

  66  #define EQUAL(table,x,y) \
          ((x)==(y) || (*table->type->compare)((x),(y)) == 0)

(st.c)
</pre>

`COLLISION` is a debug macro so we will (should) ignore it.

The parameters of `FIND_ENTRY()`, starting from the left are:

# `st_table`
# the found entry will be pointed to by this parameter
# hash value
# temporary variable

And, the second parameter will point to the found `st_table_entry*`.

At the outermost level, a `do` .. `while(0)` is used to safely wrap up a
multiple expression macro. This is `ruby`'s, or rather, C language's preprocessor
idiom. In the case of `if(1)`, there may be a danger of adding an `else` part.
In the case of `while(1)`, it becomes necessary to add a `break` at the very
end.

Also, there is no semicolon added after the `while(0)`.

<pre class="emlist">
FIND_ENTRY();
</pre>

This is so that the semicolon that is normally written at the end of an
expression will not go to waste.

h3. `st_add_direct()`

Continuing on, let us examine `st_add_direct()` which is a function that adds a
new relationship to the hash table. This function does not check if the key is
already registered. It always adds a new entry. This is the meaning of `direct`
in the function name.

▼ `st_add_direct()`
<pre class="longlist">
 308  void
 309  st_add_direct(table, key, value)
 310      st_table *table;
 311      char *key;
 312      char *value;
 313  {
 314      unsigned int hash_val, bin_pos;
 315
 316      hash_val = do_hash(key, table);
 317      bin_pos = hash_val % table->num_bins;
 318      ADD_DIRECT(table, key, value, hash_val, bin_pos);
 319  }

(st.c)
</pre>

Just as before, the `do_hash()` macro that obtains a value is called here.
After that, the next calculation is the same as at the start of
`FIND_ENTRY()`, which is to exchange the hash value for a real index.

Then the insertion operation seems to be implemented by `ADD_DIRECT()`.
Since the name is all uppercase, we can anticipate that is a macro.

▼ `ADD_DIRECT()`
<pre class="longlist">
 268  #define ADD_DIRECT(table, key, value, hash_val, bin_pos) \
 269  do {                                                     \
 270      st_table_entry *entry;                               \
 271      if (table->num_entries / (table->num_bins)           \
                              > ST_DEFAULT_MAX_DENSITY) {      \
 272          rehash(table);                                   \
 273          bin_pos = hash_val % table->num_bins;            \
 274      }                                                    \
 275                                                           \
          /* (A) */                                            \
 276      entry = alloc(st_table_entry);                       \
 277                                                           \
 278      entry->hash = hash_val;                              \
 279      entry->key = key;                                    \
 280      entry->record = value;                               \
          /* (B) */                                            \
 281      entry->next = table->bins[bin_pos];                  \
 282      table->bins[bin_pos] = entry;                        \
 283      table->num_entries++;                                \
 284  } while (0)

(st.c)
</pre>

The first `if` is an exception case so I will explain it afterwards.

(A) Allocate and initialize a `st_table_entry`. 

(B) Insert the `entry` into the start of the list.
This is the idiom for handling the list. In other words,

<pre class="emlist">
entry->next = list_beg;
list_beg = entry;
</pre>

makes it possible to insert an entry to the front of the list. This is similar
to "cons-ing" in the Lisp language. Check for yourself that even if `list_beg`
is NULL, this code holds true.

Now, let me explain the code I left aside.

▼ `ADD_DIRECT()`-`rehash`
<pre class="longlist">
 271      if (table->num_entries / (table->num_bins)           \
                              > ST_DEFAULT_MAX_DENSITY) {      \
 272          rehash(table);                                   \
 273          bin_pos = hash_val % table->num_bins;            \
 274      }                                                    \

(st.c)
</pre>

`DENSITY` is "concentration". In other words, this conditional checks if the
hash table is "crowded" or not. In the `st_table`, as the number of values that
use the same `bin_pos` increases, the longer the link list becomes. In other
words, search becomes slower. That is why for a given `bin` count, when the average elements
per bin become too many, `bin` is increased and the crowding is reduced.

The current `ST_DEFAULT_MAX_DENSITY` is

▼ `ST_DEFAULT_MAX_DENSITY`
<pre class="longlist">
  23  #define ST_DEFAULT_MAX_DENSITY 5

(st.c)
</pre>

Because of this setting, if in all `bin_pos` there are 5 `st_table_entries`,
then the size will be increased.

h3. `st_insert()`

`st_insert()` is nothing more than a combination of `st_add_direct()` and
`st_lookup()`, so if you understand those two, this will be easy.

▼ `st_insert()`
<pre class="longlist">
 286  int
 287  st_insert(table, key, value)
 288      register st_table *table;
 289      register char *key;
 290      char *value;
 291  {
 292      unsigned int hash_val, bin_pos;
 293      register st_table_entry *ptr;
 294
 295      hash_val = do_hash(key, table);
 296      FIND_ENTRY(table, ptr, hash_val, bin_pos);
 297
 298      if (ptr == 0) {
 299          ADD_DIRECT(table, key, value, hash_val, bin_pos);
 300          return 0;
 301      }
 302      else {
 303          ptr->record = value;
 304          return 1;
 305      }
 306  }

(st.c)
</pre>

It checks if the element is already registered in the table. Only when it is
not registered will it be added. If there is a insertion, return 0. If there is
no insertion, return a 1.

h2. `ID` and Symbols

I've already discussed what an `ID` is. It is a correspondence between an
arbitrary string of characters and a value. It is used to declare various
names. The actual data type is `unsigned int`.

h3. From `char*` to `ID`

The conversion from string to `ID` is executed by `rb_intern()`. This function
is rather long, so let's omit the middle.

▼ `rb_intern()` (simplified)
<pre class="longlist">
5451  static st_table *sym_tbl;       /*  char* to ID   */
5452  static st_table *sym_rev_tbl;   /*  ID to char*   */

5469  ID
5470  rb_intern(name)
5471      const char *name;
5472  {
5473      const char *m = name;
5474      ID id;
5475      int last;
5476
          /* If for a name, there is a corresponding ID that is already
          registered, then return that ID */
5477      if (st_lookup(sym_tbl, name, &id))
5478          return id;

          /* omitted ... create a new ID */

          /* register the name and ID relation */
5538    id_regist:
5539      name = strdup(name);
5540      st_add_direct(sym_tbl, name, id);
5541      st_add_direct(sym_rev_tbl, id, name);
5542      return id;
5543  }

(parse.y)
</pre>

The string and `ID` correspondence relationship can be accomplished by using the
`st_table`. There probably isn't any especially difficult part here.

What is the omitted section doing? It is treating global variable names and
instance variables names as special and flagging them. This is because in the
parser, it is necessary to know the variable's classification from the `ID`.
However, the fundamental part of `ID` is unrelated to this, so I won't explain
it here.

h3. From `ID` to `char*`

The reverse of `rb_intern()` is `rb_id2name()`, which takes an `ID` and
generates a `char*`. You probably know this, but the 2 in `id2name` is "to".
"To" and "two" have the same pronounciation, so "2" is used for "to". This
syntax is often seen.

This function also sets the `ID` classification flags so it is long. Let me
simplify it.

▼ `rb_id2name()` (simplified)
<pre class="longlist">
char *
rb_id2name(id)
    ID id;
{
    char *name;

    if (st_lookup(sym_rev_tbl, id, &name))
        return name;
    return 0;
}
</pre>

Maybe it seems that it is a little over-simplified, but in reality if we remove
the details it really becomes this simple.

The point I want to emphasize is that the found `name` is not copied. The
`ruby` API does not require (or rather, it forbids) the `free()`-ing of the
return value. Also, when parameters are passed, it always
copies them. In other words, the creation and release is
completed by one side, either by the user or by `ruby`.

So then, when creation and release cannot be accomplished (when passed it is
not returned) on a value, then a Ruby object is used. I have not yet discussed
it, but a Ruby object is automatically released when it is no longer needed,
even if we are not taking care of the object.

h3. Converting `VALUE` and `ID`

`ID` is shown as an instance of the `Symbol` class at the Ruby level.
And it can be obtained like so: `"string".intern`. The implementation of
`String#intern` is `rb_str_intern()`.

▼ `rb_str_intern()`
<pre class="longlist">
2996  static VALUE
2997  rb_str_intern(str)
2998      VALUE str;
2999  {
3000      ID id;
3001
3002      if (!RSTRING(str)->ptr || RSTRING(str)->len == 0) {
3003          rb_raise(rb_eArgError, "interning empty string");
3004      }
3005      if (strlen(RSTRING(str)->ptr) != RSTRING(str)->len)
3006          rb_raise(rb_eArgError, "string contains `\\0'");
3007      id = rb_intern(RSTRING(str)->ptr);
3008      return ID2SYM(id);
3009  }

(string.c)
</pre>

This function is quite reasonable as a `ruby` class library code example.
Please pay attention to the part where `RSTRING()` is used and casted, and
where the data structure's member is accessed.

Let's read the code. First, `rb_raise()` is merely error handling so we ignore
it for now. The `rb_intern()` we previously examined is here, and also ID2SYM
is here. `ID2SYM()` is a macro that converts `ID` to `Symbol`. 

And the reverse operation is accomplished using `Symbol#to_s` and such.
The implementation is in `sym_to_s`.

▼ `sym_to_s()`
<pre class="longlist">
 522  static VALUE
 523  sym_to_s(sym)
 524      VALUE sym;
 525  {
 526      return rb_str_new2(rb_id2name(SYM2ID(sym)));
 527  }

(object.c)
</pre>

`SYM2ID()` is the macro that converts `Symbol` (`VALUE`) to an `ID`.

It looks like the function is not doing anything unreasonable. However, it
is probably necessary to pay attention to the area around the memory handling.
`rb_id2name()` returns a `char*` that must not be `free()`. `rb_str_new2()`
copies the parameter's `char*` and uses the copy (and does not change the
parameter). In this way the policy is consistent, which allows the line to be
written just by chaining the functions.
