Translation by Clifford Escobar CAOILE

h1. Chapter 3: Names and Name Table

h2. `st_table`

`st_table` has already been mentioned as a method table and instance table.
In this chapter let us look at the detailed mechanism of the `st_table`.

h3. Summary

I previously mentioned that the `st_table` is a hash table. What is a hash
table? It is a data structure that records one-to-one relations, for
example, variable name and its value, function name and its body, etc.

However, data structures other than hash tables can, of course, record
one-to-one relations. For example, a list of following data structure will
suffice for this purpose.

<pre class="emlist">
struct entry {
    ID key;
    VALUE val;
    struct entry *next;  /* point to the next entry */
};
</pre>

However, this method is slow. If the list contains a thousand items, in the
worst case, it is necessary to traverse links a thousand times. In other
words, in proportion to the number of elements, the search time increases.
This is bad. Since ancient times, various speed improvement methods have
been conceived. The hash table is one of those improved methods. In other
words, the point is not that the hash table is necessary but that it can be
made faster.

Now then, let us examine the `st_table`. But first, this library is not
created by Matsumoto, rather:

▼ `st.c` credits
<pre class="longlist">
   1  /* This is a public domain general purpose hash table package
         written by Peter Moore @ UCB. */

(st.c)
</pre>

as shown above.

By the way, when I searched Google and found another version, it mentioned
that st_table is a contraction of "STring TABLE". However, I find it
contradictory that it has "general purpose" and "string" aspects.

h4. What is a hash table

A hash table can be thought as the following. Let us think of an array with
n items. For example, let us make n=64 (figure 1).

!images/ch_name_array.jpg(Array)!

Then let us specify a function f that takes a key and produces an integer i
from 0 to n-1 (0-63). We call this f a hash function. f when given the same
key always produces the i. For example, if we make the assumption that the
key is limited to positive integers, then if the key is divided by 64 then
the remainder will always fall between 0 and 63. This method of calculation
can become function f.

When recording relationships, given a key, function f generates i, and
place the value into index i of the array we have prepared. In other words,
the index access into an array is very fast. Therefore the fundamental idea
is to change the key into a integer.

!images/ch_name_aset.jpg(Array assignment)!

However, in the real world it isn't that easy. There is a critical problem
with this idea. Because n is only 64, if there are more than 64
relationships to be recorded, it is for certain that i will be duplicated.
It is also possible with less that 64, the same index will be allocated.
For example, given the previous hash function "key % 64", keys 65 and 129
will have a hash value of 1. This is called a hash value collision. There
are many ways to resolve a collision.

For example, if a collision occurs, then insert into the next element. 
This is called open addressing. (Figure 3).

!images/ch_name_nexti.jpg(Open addressing)!

Other than using the array like this, there are other methods like using a
pointer in each element of the array to a linked list. Then when a
collision occurs, grow the linked list. This is called chaining. (Figure
4) `st_table` uses this chaining method.

!images/ch_name_chain.jpg(Chaining)!

However, if it can be determined apriori what possible keys will be used,
it is possible to imagine a hash function that will never create
collisions. This type of function is called a "perfect hash function".
Actually, there are tools that creates a perfect hash function given a set
of arbitrary strings. GNU gperf is one of those. `ruby`'s parser
implementation uses GNU gperf but... this is not the time to discuss it.
Let us discuss this in the second part of the book. 

h3. Data Structure

Let us start looking at the source code. As written in the introductory
chapter, if there is data and code, it is better to read the data first.
The following is the data type of `st_table`.

▼ `st_table`
<pre class="longlist">
   9  typedef struct st_table st_table;

  16  struct st_table {
  17      struct st_hash_type *type;
  18      int num_bins;                   /* slot count */
  19      int num_entries;                /* total number of entries */
  20      struct st_table_entry **bins;   /* slot */
  21  };

(st.h)
</pre>

▼ `struct st_table_entry`
<pre class="longlist">
  16  struct st_table_entry {
  17      unsigned int hash;
  18      char *key;
  19      char *record;
  20      st_table_entry *next;
  21  };

(st.c)
</pre>

`st_table` is the main table structure. `st_table_entry` is a holder that
stores one value. `st_table_entry` contains a member called `next` which of
course is a linked list. This is the chain part of the chaining method.
`st_hash_type` data type is used, but I will explaine this later. First let
me explain the other parts so you can compare and understand the roles.

!images/ch_name_sttable.jpg(`st_table` data structure)!

So, let us comment on `st_hash_type`.

▼ `struct st_hash_type`
<pre class="longlist">
  11  struct st_hash_type {
  12      int (*compare)();   /* comparison function */
  13      int (*hash)();      /* hash function */
  14  };

(st.h)
</pre>

This is still Chapter 3 so let us examine it attentively.

<pre class="emlist">
int (*compare)()
</pre>

This part shows, of course, the member `compare` which has a data type of
"a pointer to a function that returns an `int`". `hash` is also the same.
This variable is substituted in the following way:

<pre class="emlist">
int
great_function(int n)
{
    /* ToDo: Do something great! */
    return n;
}

{
    int (*f)();
    f = great_function;
</pre>

And it is called like this:

<pre class="emlist">
    (*f)(7);
}
</pre>

Here let us return to the `st_hash_type` commentary. Of the two members
`hash` and `compare`, `hash` is the hash function f explained previously.

On the other hand, `compare` is a function that evaluates if the key is the
same or not. With the chaining method, in the spot with the same hash value
n, multiple elements can be inserted. To know exactly which element is
being searched for, this time it is necessary to use a comparison function
that we can absolutely trust. `compare` will be that function.

This `st_hash_type` is a good generalized technique. The hash table itself
cannot determine what the stored keys' data type will be. For example, in
`ruby`, `st_table`'s keys are `ID` or `char*` or `VALUE`, but to write the
same mechanism of hash for each (data type) is foolish. Usually, the things
that change with the different key data types are things like the hash
function. For things like memory allocation and collision detection,
usually most of the code is the same. Only the parts where the
implementation changes with a differing data type will bundled up into a
function, and a pointer to that function will be used. In this fashion, the
majority of the code that makes up the hash table implementation can
((つかいまわす ?= utilize it)).

In object-oriented languages, in the first place, you can attach a procedure
to an object and pass it (around), so this mechanism is not necessary.
Perhaps it more correct to say that this mechanism is built-in as a
language's feature.

h3. `st_hash_type` example

The usage of a data structure like `st_hash_type` is good as a
generalization. On the other hand, what kind of code it actually passes
through may be difficult to understand. If we do not examine what sort of
function is used for `hash` or `compare`, we will not grasp the reality.
For this reason, it is probably sufficient to look at `st_init_numtable()`
introduced in the previous chapter. This function creates a table for
integer data type keys.

▼ `st_init_numtable()`
<pre class="longlist">
 182  st_table*
 183  st_init_numtable()
 184  {
 185      return st_init_table(&type_numhash);
 186  }

(st.c)
</pre>

`st_init_table()` is the function that allocates the table memory and so
on. `type_numhash` becomes `st_hash_type` (it is the member name "type").
Regarding this `type_numhash`:

▼ `type_numhash`
<pre class="longlist">
  37  static struct st_hash_type type_numhash = {
  38      numcmp,
  39      numhash,
  40  };

 552  static int
 553  numcmp(x, y)
 554      long x, y;
 555  {
 556      return x != y;
 557  }

 559  static int
 560  numhash(n)
 561      long n;
 562  {
 563      return n;
 564  }

(st.c)
</pre>

Very simple. The table that the `ruby` interpreter uses is by and large
this `type_numhash`.

h3. `st_lookup()`

では今度はこの構造を使う関数を見ていこう。最初は検索用の関数から見てい
くのがいい。ハッシュテーブルを検索する関数`st_lookup()`を以下に示す。

▼ `st_lookup()`
<pre class="longlist">
 247  int
 248  st_lookup(table, key, value)
 249      st_table *table;
 250      register char *key;
 251      char **value;
 252  {
 253      unsigned int hash_val, bin_pos;
 254      register st_table_entry *ptr;
 255
 256      hash_val = do_hash(key, table);
 257      FIND_ENTRY(table, ptr, hash_val, bin_pos);
 258
 259      if (ptr == 0) {
 260          return 0;
 261      }
 262      else {
 263          if (value != 0)  *value = ptr->record;
 264          return 1;
 265      }
 266  }

(st.c)
</pre>

重要なところはほとんど`do_hash()`と`FIND_ENTRY()`で行われているようだ。
順番に見る。

▼ `do_hash()`
<pre class="longlist">
  68  #define do_hash(key,table) (unsigned int)(*(table)->type->hash)((key))

(st.c)
</pre>

念のため書くと、マクロ本体のややこしい部分は

<pre class="emlist">
(table)->type->hash
</pre>

という関数ポインタから、`key`を引数にして関数を起動する記法である。
`*`は`table`にはかからない。つまり型ごとに用意されたハッシュ関数
`type->hash`でもって`key`に対するハッシュ値を求めるのがこのマクロだ。

続いて`FIND_ENTRY()`を見る。

▼ `FIND_ENTRY()`
<pre class="longlist">
 235  #define FIND_ENTRY(table, ptr, hash_val, bin_pos) do {\
 236      bin_pos = hash_val%(table)->num_bins;\
 237      ptr = (table)->bins[bin_pos];\
 238      if (PTR_NOT_EQUAL(table, ptr, hash_val, key)) {\
 239          COLLISION;\
 240          while (PTR_NOT_EQUAL(table, ptr->next, hash_val, key)) {\
 241              ptr = ptr->next;\
 242          }\
 243          ptr = ptr->next;\
 244      }\
 245  } while (0)

 227  #define PTR_NOT_EQUAL(table, ptr, hash_val, key) ((ptr) != 0 && \
          (ptr->hash != (hash_val) || !EQUAL((table), (key), (ptr)->key)))

  66  #define EQUAL(table,x,y) \
          ((x)==(y) || (*table->type->compare)((x),(y)) == 0)

(st.c)
</pre>

`COLLISION`はデバッグ用のマクロなので無視していい(すべきだ)。

`FIND_ENTRY()`の引数は前から

# `st_table`
# 使うべきテンポラリ変数
# ハッシュ値
# 検索キー

である。また二番目の引数には見付かった`st_table_entry*`が保存される。

それと一番外側には複数の式からなるマクロを安全にくくるための`do`〜
`while(0)`が使ってある。これは`ruby`の、と言うよりC言語のプリプロセッ
サのイディオムだ。`if(1)`だと`else`が付いてしまう恐れがある。
`while(1)`だと最後に`break`が必要になる。

`while(0)`のあとにセミコロンを置かないのもポイントだ。なぜなら、

<pre class="emlist">
FIND_ENTRY();
</pre>

と普通に書いたときに文末のセミコロンが無駄にならないからである。

h3. `st_add_direct()`

続いてハッシュテーブルに新しい関連付けを登録する関数`st_add_direct()`を
見よう。この関数はキーが既に登録されているかどうかを検査せず、無条件
に新しいエントリを追加する。それがつまり関数名の「`direct`」の意味だ。

▼ `st_add_direct()`
<pre class="longlist">
 308  void
 309  st_add_direct(table, key, value)
 310      st_table *table;
 311      char *key;
 312      char *value;
 313  {
 314      unsigned int hash_val, bin_pos;
 315
 316      hash_val = do_hash(key, table);
 317      bin_pos = hash_val % table->num_bins;
 318      ADD_DIRECT(table, key, value, hash_val, bin_pos);
 319  }

(st.c)
</pre>

先程と同じくハッシュ値を求めるマクロ`do_hash()`の呼び出しがある。その
次の計算も`FIND_ENTRY()`の最初にあったもので、ハッシュ値を実際のインデッ
クスに変換する。

そして挿入操作自体は`ADD_DIRECT()`で実行されているようだ。これも、名前
が大文字であることから想像できるように、マクロである。

▼ `ADD_DIRECT()`
<pre class="longlist">
 268  #define ADD_DIRECT(table, key, value, hash_val, bin_pos) \
 269  do {                                                     \
 270      st_table_entry *entry;                               \
 271      if (table->num_entries / (table->num_bins)           \
                              > ST_DEFAULT_MAX_DENSITY) {      \
 272          rehash(table);                                   \
 273          bin_pos = hash_val % table->num_bins;            \
 274      }                                                    \
 275                                                           \
          /*(A)*/                                            \
 276      entry = alloc(st_table_entry);                       \
 277                                                           \
 278      entry->hash = hash_val;                              \
 279      entry->key = key;                                    \
 280      entry->record = value;                               \
          /*(B)*/                                            \
 281      entry->next = table->bins[bin_pos];                  \
 282      table->bins[bin_pos] = entry;                        \
 283      table->num_entries++;                                \
 284  } while (0)

(st.c)
</pre>

最初の`if`は例外的な場合を扱っているので後にして、その次から。

(A)`st_table_entry`を割り当て、初期化して、

(B)`entry`をリストの先頭に追加する。
こちらはリストを扱うときのイディオムだ。つまり

<pre class="emlist">
entry->next = list_beg;
list_beg = entry;
</pre>

でリストの先頭にエントリを追加することができる。Lispの用語を使って
「cons(コンス)する」と言うこともある。もし`list_beg`が`NULL`でも
このコードは通用することを確認しよう。

最後に、棚上げにしておいたコードを説明する。

▼ `ADD_DIRECT()`-`rehash`
<pre class="longlist">
 271      if (table->num_entries / (table->num_bins)           \
                              > ST_DEFAULT_MAX_DENSITY) {      \
 272          rehash(table);                                   \
 273          bin_pos = hash_val % table->num_bins;            \
 274      }                                                    \

(st.c)
</pre>

`DENSITY`とは「濃度」。つまりこの条件式ではハッシュテーブルが「混んで
いないか」確かめている。
`st_table`では同じ`bin_pos`を使っている値が増えるほどリンクリストが
長くなる、つまり検索が遅くなる。だから`bin`の数に対
して要素数が多くなりすぎたら、`bin`を増やして混雑を緩和するわけだ。

現在`ST_DEFAULT_MAX_DENSITY`は

▼ `ST_DEFAULT_MAX_DENSITY`
<pre class="longlist">
  23  #define ST_DEFAULT_MAX_DENSITY 5

(st.c)
</pre>

と設定されているから、全ての`bin_pos`に五つの`st_table_entry`が連なって
いるような状況になったらサイズを増やす、ということになる。

h3. `st_insert()`

`st_insert()`は`st_add_direct()`と`st_lookup()`の組み合わせにすぎないので
この二つが分かれば簡単である。

▼ `st_insert()`
<pre class="longlist">
 286  int
 287  st_insert(table, key, value)
 288      register st_table *table;
 289      register char *key;
 290      char *value;
 291  {
 292      unsigned int hash_val, bin_pos;
 293      register st_table_entry *ptr;
 294
 295      hash_val = do_hash(key, table);
 296      FIND_ENTRY(table, ptr, hash_val, bin_pos);
 297
 298      if (ptr == 0) {
 299          ADD_DIRECT(table, key, value, hash_val, bin_pos);
 300          return 0;
 301      }
 302      else {
 303          ptr->record = value;
 304          return 1;
 305      }
 306  }

(st.c)
</pre>

既に要素がテーブルに登録されているかどうか調べ、
登録されていないときにだけ追加する。
実際に追加したら真を返す。追加しなかったら偽を返す。

h2. `ID`とシンボル

`ID`というものが何であるかということは既に述べた。任意の文字列と一対一
に対応する数値のことで、いろいろな名前を表すために使われる。実際の型は
`unsigned int`だ。

h3. `char*`から`ID`

文字列から`ID`への変換は`rb_intern()`で行っている。
この関数はやや長いので途中を省略して掲載しよう。

▼ `rb_intern()`(簡約版)
<pre class="longlist">
5451  static st_table *sym_tbl;       /*  char* → ID   */
5452  static st_table *sym_rev_tbl;   /*  ID → char*   */

5469  ID
5470  rb_intern(name)
5471      const char *name;
5472  {
5473      const char *m = name;
5474      ID id;
5475      int last;
5476
          /* 既にnameに対応するIDが登録されていたらそれを返す */
5477      if (st_lookup(sym_tbl, name, &id))
5478          return id;

          /* 省略……新しいIDを作る */

          /* nameとIDの関連を登録する */
5538    id_regist:
5539      name = strdup(name);
5540      st_add_direct(sym_tbl, name, id);
5541      st_add_direct(sym_rev_tbl, id, name);
5542      return id;
5543  }

(parse.y)
</pre>

文字列と`ID`の一対一対応は`st_table`を使って実現できる。
特に難しいところはないだろう。

省略しているところでは何をしているかと言うと、グローバル変数名や
インスタンス変数名を特別扱いしてフラグを立てているのである。
パーサで、`ID`から変数
の種類を知る必要があるからだ。だが`ID`の原理自体にはあまり関りがないこと
なので、ここには載せない。

h3. `ID`から`char*`

`rb_intern()`の逆、`ID`から`char*`を得るために使うのが`rb_id2name()`である。
御存知と思うが、`id2name`の2はtoのことだ。toとtwoの発音が同じだから
代わりに使っているのだ。この記法はプログラムではわりとよく見かける。

この関数も`ID`の種別フラグをいろいろしているために長いので、思い切り
簡単にしてものを見ておくことにする。

▼ `rb_id2name()`(簡約版)
<pre class="longlist">
char *
rb_id2name(id)
    ID id;
{
    char *name;

    if (st_lookup(sym_rev_tbl, id, &name))
        return name;
    return 0;
}
</pre>

ちょっと簡単にしすぎたような気もするが、
実際に小細工を削ればこんなものなのだ。

ここで注目したいのは、検索した`name`をコピーしていないことである。`ruby`の
APIでは返り値は常に、`free()`する必要はない(してはならない)。また引数
を渡した場合は常にコピーして使ってくれる。つまり生成と解放が常にユーザか
`ruby`か、片方で完結するようになっているのだ。

では生成と解放を対応させることができない(渡したら渡しっぱなしになる)
値の場合はどうするかというと、その時はRubyオブジェクトを使うようにする。
まだ話していないが、Rubyのオブジェクトは我々が面倒を見なくとも必要が
なくなったときに自動的に解放されるからだ。

h3. `VALUE`と`ID`の変換

`ID`はRubyレベルでは`Symbol`クラスのインスタンスとして表され、`"string".intern`の
ようにして得ることができる。その`String#intern`の実体が`rb_str_intern()`だ。

▼ `rb_str_intern()`
<pre class="longlist">
2996  static VALUE
2997  rb_str_intern(str)
2998      VALUE str;
2999  {
3000      ID id;
3001
3002      if (!RSTRING(str)->ptr || RSTRING(str)->len == 0) {
3003          rb_raise(rb_eArgError, "interning empty string");
3004      }
3005      if (strlen(RSTRING(str)->ptr) != RSTRING(str)->len)
3006          rb_raise(rb_eArgError, "string contains `\\0'");
3007      id = rb_intern(RSTRING(str)->ptr);
3008      return ID2SYM(id);
3009  }

(string.c)
</pre>

この関数は`ruby`のクラスライブラリのコード例としてもなかなか手頃だ。
`RSTRING()`を使ってキャストし、構造体メンバにアクセスしているところに
注目してほしい。

コードを読もう。まず`rb_raise()`は単なるエラー処理なのでとりあえず無視。
先程見たばかりの`rb_intern()`があり、`ID2SYM()`がある。`ID2SYM()`は`ID`を
`Symbol`に変換するマクロだった。

またこの逆の操作は`Symbol#to_s`などで行える。
その実体は`sym_to_s`である。

▼ `sym_to_s()`
<pre class="longlist">
 522  static VALUE
 523  sym_to_s(sym)
 524      VALUE sym;
 525  {
 526      return rb_str_new2(rb_id2name(SYM2ID(sym)));
 527  }

(object.c)
</pre>

`SYM2ID()`は`Symbol`(`VALUE`)を`ID`に変換するマクロである。

なんてことはない関数に見えるが、メモリ処理まわりには注意すべきだろう。
`rb_id2name()`は`free()`してはならない`char*`を返し、`rb_str_new2()`は引数の
`char*`をコピーして使う(また引数を変更したりはしない)。このように
方針が一貫しているからこそ関数の連鎖だけで書けるのである。

<hr>

御意見・御感想・誤殖の指摘などは
"青木峰郎 &lt;aamine@loveruby.net&gt;":mailto:aamine@loveruby.net
までお願いします。

"『Rubyソースコード完全解説』
はインプレスダイレクトで御予約・御購入いただけます (書籍紹介ページへ飛びます)。":http://direct.ips.co.jp/directsys/go_x_TempChoice.cfm?sh_id=EE0040&amp;spm_id=1&amp;GM_ID=1721

Copyright (c) 2002-2004 Minero Aoki, All rights reserved.
